"""Property tests for QA Review Agent models and diff utilities.

Tests for review models (Suggestion, ReviewResult, ReviewStats) and
diff utilities (generate_unified_diff, parse_diff, apply_diff).
"""

import pytest
from hypothesis import given, settings, assume
from hypothesis import strategies as st
from pydantic import ValidationError

from vbagent.models.review import (
    ReviewIssueType,
    Suggestion,
    ReviewResult,
    ReviewStats,
)
from vbagent.models.diff import (
    generate_unified_diff,
    parse_diff,
    apply_diff_to_content,
)


# Valid issue types
VALID_ISSUE_TYPES = [
    "latex_syntax",
    "physics_error", 
    "solution_error",
    "variant_inconsistency",
    "formatting",
    "other",
]


# Strategies for generating test data
issue_type_strategy = st.sampled_from(VALID_ISSUE_TYPES)
confidence_strategy = st.floats(min_value=0.0, max_value=1.0, allow_nan=False)
non_empty_text = st.text(min_size=1, max_size=100).filter(lambda x: x.strip())
file_path_strategy = st.text(min_size=1, max_size=50).filter(
    lambda x: x.strip() and "/" not in x[:1]  # Avoid leading slash
)


# Strategy for generating text content suitable for diffs
# Avoid problematic characters that could interfere with diff parsing
diff_safe_text = st.text(
    alphabet=st.characters(
        whitelist_categories=("L", "N", "P", "S", "Zs"),
        blacklist_characters="\r\x00",
    ),
    min_size=1,
    max_size=200,
).filter(lambda x: x.strip())


@st.composite
def suggestion_strategy(draw):
    """Generate valid Suggestion instances."""
    original = draw(diff_safe_text)
    suggested = draw(diff_safe_text)
    file_path = draw(file_path_strategy)
    
    # Generate a real diff
    diff = generate_unified_diff(original, suggested, file_path)
    
    return {
        "issue_type": draw(issue_type_strategy),
        "file_path": file_path,
        "description": draw(non_empty_text),
        "reasoning": draw(non_empty_text),
        "confidence": draw(confidence_strategy),
        "original_content": original,
        "suggested_content": suggested,
        "diff": diff,
    }


# =============================================================================
# Property 3: Suggestion Model Validity
# =============================================================================

@given(data=suggestion_strategy())
@settings(max_examples=100)
def test_property_suggestion_model_validity(data: dict):
    """
    **Feature: qa-review-agent, Property 3: Suggestion Model Validity**
    **Validates: Requirements 2.3, 2.4**
    
    Property: For any Suggestion generated by the QA Review Agent, the suggestion
    SHALL have a valid issue_type enum value, confidence between 0.0 and 1.0,
    and a diff field in unified diff format (empty if no changes).
    """
    suggestion = Suggestion(**data)
    
    # Property: issue_type must be valid enum value
    assert suggestion.issue_type.value in VALID_ISSUE_TYPES, (
        f"issue_type '{suggestion.issue_type}' not in valid set"
    )
    
    # Property: confidence must be between 0 and 1
    assert 0.0 <= suggestion.confidence <= 1.0, (
        f"confidence {suggestion.confidence} not in [0, 1]"
    )
    
    # Property: diff format validation
    # If content is different, diff must be non-empty and in unified format
    # If content is same, diff can be empty
    if suggestion.original_content.strip() != suggestion.suggested_content.strip():
        assert suggestion.diff, "diff field must be non-empty when content differs"
        assert "---" in suggestion.diff, (
            "diff must be in unified diff format (contain '---' header)"
        )


@given(confidence=st.floats().filter(lambda x: x < 0.0 or x > 1.0))
@settings(max_examples=50)
def test_property_invalid_confidence_rejected(confidence: float):
    """
    **Feature: qa-review-agent, Property 3: Suggestion Model Validity**
    **Validates: Requirements 2.3**
    
    Property: For any confidence value outside [0, 1], the Suggestion model
    SHALL reject the input with a validation error.
    """
    assume(not (confidence != confidence))  # Skip NaN
    
    with pytest.raises(ValidationError):
        Suggestion(
            issue_type="latex_syntax",
            file_path="test.tex",
            description="Test issue",
            reasoning="Test reasoning",
            confidence=confidence,
            original_content="original",
            suggested_content="modified",
            diff="--- a/test.tex\n+++ b/test.tex\n",
        )


@given(issue_type=st.text(min_size=1).filter(lambda x: x not in VALID_ISSUE_TYPES))
@settings(max_examples=50)
def test_property_invalid_issue_type_rejected(issue_type: str):
    """
    **Feature: qa-review-agent, Property 3: Suggestion Model Validity**
    **Validates: Requirements 2.3**
    
    Property: For any invalid issue_type, the Suggestion model SHALL reject
    the input with a validation error.
    """
    assume(issue_type.strip())
    
    with pytest.raises(ValidationError):
        Suggestion(
            issue_type=issue_type,
            file_path="test.tex",
            description="Test issue",
            reasoning="Test reasoning",
            confidence=0.8,
            original_content="original",
            suggested_content="modified",
            diff="--- a/test.tex\n+++ b/test.tex\n",
        )


# =============================================================================
# Property 4: Diff Round-Trip
# =============================================================================

@given(
    original=diff_safe_text,
    modified=diff_safe_text,
)
@settings(max_examples=100)
def test_property_diff_round_trip(original: str, modified: str):
    """
    **Feature: qa-review-agent, Property 4: Diff Round-Trip**
    **Validates: Requirements 3.5, 3.6**
    
    Property: For any original content and modified content, generating a unified
    diff and then parsing it SHALL produce content equivalent to the original inputs.
    """
    # Skip case where content is identical (empty diff is valid)
    assume(original.strip() != modified.strip())
    
    file_path = "test.txt"
    
    # Generate diff
    diff = generate_unified_diff(original, modified, file_path)
    
    # Parse diff back
    parsed = parse_diff(diff)
    assert parsed is not None, "Diff should be parseable when content differs"
    parsed_original, parsed_modified = parsed
    
    # Verify round-trip (strip to handle trailing newline normalization)
    assert parsed_original.strip() == original.strip(), (
        f"Original content mismatch:\nExpected: {repr(original)}\nGot: {repr(parsed_original)}"
    )
    assert parsed_modified.strip() == modified.strip(), (
        f"Modified content mismatch:\nExpected: {repr(modified)}\nGot: {repr(parsed_modified)}"
    )


# =============================================================================
# Property 5: Diff Application Correctness
# =============================================================================

@given(
    original=diff_safe_text,
    modified=diff_safe_text,
)
@settings(max_examples=100)
def test_property_diff_application_correctness(original: str, modified: str):
    """
    **Feature: qa-review-agent, Property 5: Diff Application Correctness**
    **Validates: Requirements 4.2**
    
    Property: For any file with original content and a valid unified diff,
    applying the diff SHALL produce content matching the expected modified content.
    """
    file_path = "test.txt"
    
    # Generate diff
    diff = generate_unified_diff(original, modified, file_path)
    
    # Apply diff to original content
    result = apply_diff_to_content(original, diff)
    
    # Verify application produces expected result
    assert result is not None, "Diff application should succeed for valid diff"
    # When content is identical, result should match original
    # When content differs, result should match modified
    if original.strip() == modified.strip():
        assert result.strip() == original.strip(), (
            f"Applied content mismatch (identical case):\nExpected: {repr(original)}\nGot: {repr(result)}"
        )
    else:
        assert result.strip() == modified.strip(), (
            f"Applied content mismatch:\nExpected: {repr(modified)}\nGot: {repr(result)}"
        )


# =============================================================================
# Property 13: Failed Diff Preserves Original
# =============================================================================

@given(
    original=diff_safe_text,
    different_content=diff_safe_text,
    modified=diff_safe_text,
)
@settings(max_examples=100)
def test_property_failed_diff_preserves_original(
    original: str, different_content: str, modified: str
):
    """
    **Feature: qa-review-agent, Property 13: Failed Diff Preserves Original**
    **Validates: Requirements 8.1**
    
    Property: For any file and an invalid or inapplicable diff, attempting to
    apply the diff SHALL return None (indicating failure) and not modify content.
    """
    # Ensure different_content is actually different from original
    assume(original.strip() != different_content.strip())
    # Ensure we have a non-empty diff (original != modified)
    assume(original.strip() != modified.strip())
    
    file_path = "test.txt"
    
    # Generate diff for original -> modified
    diff = generate_unified_diff(original, modified, file_path)
    
    # Try to apply diff to different content (should fail)
    result = apply_diff_to_content(different_content, diff)
    
    # Verify that application fails (returns None)
    assert result is None, (
        "Diff application should fail when content doesn't match expected original"
    )
